\documentclass[a4paper]{article}

\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{times} % assumes new font selection scheme installed
\usepackage{verbatim}
\usepackage{natbib}
\usepackage{color}
\usepackage{url}
\usepackage{graphicx}
\usepackage[ruled,linesnumbered,vlined]{algorithm2e}
\usepackage{amsmath,amsfonts,amssymb,bm,amsthm}
\usepackage{listings}

%\lstdefineformat{prompt}{~=\( \sim \)}
%\lstset{basicstyle=\ttfamily,format=prompt}
\lstset{basicstyle=\ttfamily}

%From mitko
\newcommand{\subst}[2]{(#1 \leftarrow #2)}
\newcommand{\proj}[2]{\left.#1\right|_{#2}}

\newcommand{\mbm}[1]{\mbox{\boldmath $#1$}}
%\usepackage{tabularx,colortbl}
\usepackage{bbm} % bbm fonts
\usepackage{subfigure}  % use for side-by-side figures
%\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
\usepackage{soul}
\usepackage{cleveref}

%COLORS
\definecolor{gray}{rgb}{0.8,0.8,0.8}\newcommand{\gray}{\color{gray}}
\definecolor{darkgray}{rgb}{0.6,0.6,0.6}\newcommand{\darkgray}{\color{darkgray}}
\definecolor{white}{rgb}{1.0,1.0,1.0}\newcommand{\white}{\color{white}}
\definecolor{blue}{rgb}{0.0,0.0,1.0}\newcommand{\blue}{\color{blue}}
\definecolor{mygray}{rgb}{0.8,0.8,0.8}\newcommand{\mygray}{\color{mygray}}
\definecolor{mydarkgray}{rgb}{0.6,0.6,0.6}\newcommand{\mydarkgray}{\color{mydarkgray}}
\definecolor{mydarkgrayA}{rgb}{0.3,0.3,0.3}\newcommand{\mydarkgrayA}{\color{mydarkgrayA}}
\definecolor{mywhite}{rgb}{1.0,1.0,1.0}\newcommand{\mywhite}{\color{mywhite}}

% Federico's gray box
\newcommand{\graybox}[1]{\vspace{0.3cm}\noindent
  \fcolorbox{black}{mygray}{\parbox{0.985\textwidth}{#1}}
\vspace{0.3cm}}

% Federico's gray box w/ title
\newcommand{\grayboxt}[2]{\vspace{0.3cm}\noindent
%  \fcolorbox{black}{mygray}{\parbox{0.985\textwidth}{{\bf #1} #2}}
  \fcolorbox{black}{mygray}{\begin{minipage}{0.985\textwidth}{\bf #1} #2\end{minipage}}
\vspace{0.3cm}}

% Mitko's gray box
\newcommand{\gbox}[1]{
  \begin{center}
    \fcolorbox{black}{gray}{
      \begin{minipage}[b]{0.98\textwidth}
        \begin{center}
          %\vspace{2mm}
          \begin{minipage}{0.97\textwidth}
            #1 
          \end{minipage}
          \vspace{2mm}
        \end{center}
      \end{minipage}
    }
  \end{center}
}

% Mitko's white box
\newcommand{\wbox}[1]{
  \begin{center}
    \fcolorbox{black}{white}{
      \begin{minipage}[b]{0.98\textwidth}
        \begin{center}
          %\vspace{2mm}
          \begin{minipage}{0.97\textwidth}
            #1 
          \end{minipage}
          \vspace{2mm}
        \end{center}
      \end{minipage}
    }
  \end{center}
}


\newtheorem{theo}{Theorem}
\newtheorem{defin}{Definition}
\newtheorem{reduction}{Reduction}
\newtheorem{prop}{Property}
\newtheorem{remark}{Remark}
\newtheorem{lemma}{Lemma}
\newtheorem{coro}{Corollary}
\newtheorem{scen}{Scenario}
\newtheorem{ex}{Exercise}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\title{Advanced Aritificial Intelligence (DT4048)\\{\em Lab 1: Uninformed and Informed Search}}

\author{Federico Pecora\\Center for Applied Autonomous Sensor Systems\\\"Orebro University, SE-70182 Sweden\\\url{federico.pecora@oru.se}}

\date{Fall term 2019 (HT2019)}

\begin{document}

\maketitle

\section{Introduction}

In this lab we explore the practical aspects of uninformed and informed (heuristic) search.  Our running example is the well-known {\bf Rubik's Cube} combinatorial puzzle.
\begin{figure}[!ht]
\centering
\input{fig/rc.pdf_t}
\caption{{\small The Rubik's cube puzzle was invented by Hungarian architect Ern\H{o} Rubik in 1975.}}
\label{fig:rc}
\end{figure}
The objective is to achieve, by rotating the vertical or horizontal ``discs'' of the cube, a configuration where all faces have one color (see Fig.~\ref{fig:rc}), which we call a {\em solved}, or {\em goal} state. In this lab, we will work on solving the Rubik's Cube puzzle with uninformed and informed search techniques. Please take a moment to recall the theory covered in class --- see parts 1--4 of the course slides on Blackboard.

\section{Setup}
The code base you will be using in this lab depends on the Java implementation of the AIMA library (\url{https://github.com/aimacode/aima-java}).  The necessary libraries are already included in the code base.
%automatically downloaded by the build environment which you will use to build the codebase (Gradle).
Open a command prompt, and check out the lab code base as follows:
\begin{lstlisting}
$ git clone https://github.com/FedericoPecora/\
advanced-ai-lab-dt4048.git
\end{lstlisting}
Build the code base with Gradle:
\begin{lstlisting}
$ cd advanced-ai-lab-dt4048
$ ./gradlew install
\end{lstlisting}
If no errors were encountered, you can now use Gradle to automatically set up an Eclipse project:
\begin{lstlisting}
$ ./gradlew eclipse
\end{lstlisting}
% On the PCs in T002, issuing command {\tt eclipse} starts the Eclipse C/C++ IDE.  For this lab you need the Eclipse Java IDE, which is started as follows:
% \begin{lstlisting}
% $ cd
% $ eclipse/eclipse
% \end{lstlisting}
Once you have launched the Eclipse Java IDE, create a new Java project, de-select ``Use default location'', and browse to the path of the downloaded code base. You are now ready to start!

\section{Representation}
The first step in achieving an automated procedure for solving any problem is to decide on a representation to use for describing the {\em states} explored during search.  Many representations are possible for the Rubik's Cube, and we have implemented one for you.

\begin{figure}[!ht]
\centering
\input{fig/rcState.pdf_t}
\caption{{\small Elements used to represent the state of the Rubik's Cube.}}
\label{fig:rcState}
\end{figure}

A state is represented by an $n \times n \times n$ array of {\tt Cubie} objects, each of which represents one of the small cubes that make up the Rubik's Cube. This representation works for Rubik's cubes of arbitrary size $n$, where $n$ is the length in {\tt Cubies} of an edge of the Rubik's cube (hence, a ``common'' Rubik's cube, such as the one depicted in Figure~\ref{fig:rcState}, has size $n = 3$ and is composed of 27 {\tt Cubies} in total).

Each {\tt Cubie} has 6 {\tt Face}s, but not all of them are visible.  A Rubik's Cube is an instance of class {\tt RubiksCube}, which maintains the 3D array of {\tt Cubie}s and provides the methods that implement the moves (i.e., how the state of the Rubik's Cube is altered by each move).  By convention (see Figure~\ref{fig:rcState}), the yellow face is the ``front'' face, the white face is the ``back'' face, the red face is the ``top'' face, the green face is the ``left'' face, the blue face is the ``right'' face, and the orange face is the ``bottom'' face.  

The moves are defined as in Figure~\ref{fig:rcMoves}.  Note that in the Rubik's Cube of size $n = 3$, the center {\tt Cubie}s remain fixed, hence, the middle of the ``front'' face will always be yellow, the middle of the ``left'' face will always be green, and so on. As a consequence, there is no need to define a move for rotating the ``center'' disc.

\begin{figure}[!ht]
\centering
\input{fig/rcMoves.pdf_t}
\caption{{\small Moves used to expand states: {\tt FRONT} and {\tt LEFT} (shown), {\tt RIGHT}, {\tt BACK}, {\tt TOP}, {\tt BOTTOM}, and their inverses.}}
\label{fig:rcMoves}
\end{figure}

The constructor {\tt RubiksCube(n,r)} can be invoked to create an initial state for the Rubik's Cube problem, where {\tt n} is the size of the Rubik's Cube, and {\tt r} is a seed for creating an initial unsolved state. In this lab, we will focus on cubes with size $2 \leq n \leq 3$, although the implementation can be easily extended to accommodate $n > 3$.  The creation of an initial state based on {\tt r} consists of applying {\tt r} random moves to the solved state.  You can use larger values of {\tt r} to create more challenging problems --- note, however, that {\tt r} is not a good estimator of problem difficulty.

\section{Search}
In this lab we will use the AIMA implementations of uninformed and informed search algorithms.  To create a problem, four ingredients are needed: (1)~an initial state, (2)~a function for computing the actions that are applicable in a given state, (3)~a function for computing the state resulting from the application of a given action in a given state, and (4)~a goal test function. (1)~is an instance of class {\tt RubiksCube}; (2)~and (3)~are provided by methods of class {\tt RubiksCubeFunctionFactory}; (4) is an instance of class {\tt RCgoalTest}. A {\tt Problem} is thus instantiated as follows:

\begin{lstlisting}
Problem problem =
  new Problem(rubiksCube,
    RubiksCubeFunctionFactory.getSymActionsFunction(),
    RubiksCubeFunctionFactory.getResultFunction(),
    new RCgoalTest());
\end{lstlisting}

\noindent A search algorithm (e.g., Breadth First Search) is instantiated as follows:

\begin{lstlisting}
SearchForActions search =
  new BreadthFirstSearch(new TreeSearch());
\end{lstlisting}

\noindent and search is invoked by calling the method {\tt search.findActions(problem)}.  Note that tree search was used in the example --- a {\tt GraphSearch} class is also provided by the AIMA library.  Class {\tt TestRubiksCube} contains an initial example to start with. The example also opens a visualization of a Rubik's cube in its initial solved state, and updates this representation with the initial random moves. If the search finds a path to the goal state, the resulting actions are also animated in the visualization. 

\section{Uninformed Search Strategies}

{\ex{}\label{ex:ex1} Which among Breadth First Search and Depth First Search is more likely to solve a Rubik's Cube?  Write down your hypothesis, then solve a randomly generated Rubik's Cube.  Explain in writing the results you observe.\vspace{0.1cm}}

{\ex{}\label{ex:ex2} Why does using Graph Search alter the results of the previous exercise?  How in particular does this affect DFS?\vspace{0.1cm}}

{\ex{}\label{ex:ex3} What does this mean, and when do you encounter this problem?  
\begin{lstlisting}
Exception in thread "main" java.lang.OutOfMemoryError:
  GC overhead limit exceeded
    at RubiksCube.copyFaces(RubiksCube.java:316)
    at RubiksCube.rotate(RubiksCube.java:436)
        ...
\end{lstlisting}
How can the problem be overcome (without using heuristics)?  Try your solution and write down your observations.
\vspace{0.1cm}}

{\ex{}\label{ex:ex4} The moves you have used so far generate a symmetric search space, meaning that for all moves there exists an inverse (e.g., the changes brought about by action {\tt FRONT} are undone by action {\tt FRONTI}).  Can we remove the inverse moves? Is this true in general or only for the Rubik's Cube? Try the search strategies in Exercises~\ref{ex:ex1}--\ref{ex:ex3} with the modified action set --- to do so, replace the call to factory method
\begin{lstlisting}
RubiksCubeFunctionFactory.getSymActionsFunction()
\end{lstlisting}
with
\begin{lstlisting}
RubiksCubeFunctionFactory.getAsymActionsFunction()
\end{lstlisting}
\vspace{0.1cm}}


\section{Informed Search Strategies}
A possible heuristic for the Rubik's Cube is the number of {\tt Cubie}s that are not in the goal position.  An implementation of this heuristic is provided for you in the code base (see class {\tt MisplacedCubiesNotAdmissible}).

{\ex{}\label{ex:ex5} The {\tt MisplacedCubiesNotAdmissible} heuristic is not admissible --- why? Modify the heuristic to make it admissible, implementing it as a new class {\tt MisplacedCubiesAdmissible}. Run $\text{A}^\star$ with the two heuristics and compare the results.\vspace{0.1cm}}

%{\ex{}\label{ex:ex6} Run $\text{A}^\star$ with the {\tt MisplacedCubiesAdmissible} heuristic and compare the results obtained with the non-admissible one.\vspace{0.1cm}}

{\ex{}\label{ex:ex7} Implement the 3D Manhattan distance heuristic for the Rubik's Cube.  Why is 3D Manhattan distance not admissible?  Modify it to make it admissible, run $\text{A}^\star$ with the new heuristic and compare to the results obtained in Exercise~\ref{ex:ex5}.\vspace{0.1cm}}

{\ex{}\label{ex:ex8} There are fewer corner cubies than there are edge cubies, hence the expected 3D Manhattan distance of corner cubies is lower. Implement the heuristic {\tt CornerManhattanDistance}, which computes the sum of 3D Manhattan distances of corner cubies, and the heuristic {\tt EdgeManhattanDistance}, which does the same but only for edge cubies. Which among the two will perform better?  Write your thoughts before implementing the heuristics, then verify with your implementation.\vspace{0.1cm}}

{\ex{}\label{ex:ex9} Devise and implement a heuristic that is guaranteed to perform better than, or as well as, all heuristics you have used so far.\vspace{0.1cm}}

{\ex{}\label{ex:ex10} It has been shown that $\text{IDA}^\star$ achieves the best performance on the Rubik's Cube puzzle.  Implement this algorithm and verify this claim.\vspace{0.1cm}}

{\ex{}\label{ex:ex11} The {\tt SearchForActions} interface is also implemented by local search algorithms in the AIMA library. We can therefore, in principle, use local search to solve the Rubik's cube. Try solving the Rubik's cube with Simulated Annealing (see class {\tt SimulatedAnnealingSearch}), using as energy function any of the heuristics you have used in the previous exercises. Why can't Simulated Annealing solve even the simplest problems obtained with $\text{{\tt r}} = 1$?\vspace{0.1cm}}

{\ex{}\label{ex:ex12} Another local search algorithm we have studied can be used to solve simple Rubik's cube problems (e.g., problems obtained with $1 \leq \text{{\tt r}} \leq 3$). Which one? Explain why and try it out (the AIMA library implements this algorithm).\vspace{0.1cm}}

%\bibliographystyle{apalike}
%\bibliography{metaCSP}

\end{document}


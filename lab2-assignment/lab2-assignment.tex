\documentclass[a4paper]{article}

\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{times} % assumes new font selection scheme installed
\usepackage{verbatim}
\usepackage{natbib}
\usepackage{color}
\usepackage{url}
\usepackage{graphicx}
%\usepackage[ruled,linesnumbered,vlined]{algorithm2e}
\usepackage{amsmath,amsfonts,amssymb,bm,amsthm}
\usepackage{listings}

%\lstdefineformat{prompt}{~=\( \sim \)}
%\lstset{basicstyle=\ttfamily,format=prompt}
\lstset{basicstyle=\ttfamily}

%From mitko
\newcommand{\subst}[2]{(#1 \leftarrow #2)}
\newcommand{\proj}[2]{\left.#1\right|_{#2}}

\newcommand{\mbm}[1]{\mbox{\boldmath $#1$}}
%\usepackage{tabularx,colortbl}
\usepackage{bbm} % bbm fonts
\usepackage{subfigure}  % use for side-by-side figures
%\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
\usepackage{soul}
\usepackage{cleveref}

%COLORS
\definecolor{gray}{rgb}{0.8,0.8,0.8}\newcommand{\gray}{\color{gray}}
\definecolor{darkgray}{rgb}{0.6,0.6,0.6}\newcommand{\darkgray}{\color{darkgray}}
\definecolor{white}{rgb}{1.0,1.0,1.0}\newcommand{\white}{\color{white}}
\definecolor{blue}{rgb}{0.0,0.0,1.0}\newcommand{\blue}{\color{blue}}
\definecolor{mygray}{rgb}{0.8,0.8,0.8}\newcommand{\mygray}{\color{mygray}}
\definecolor{mydarkgray}{rgb}{0.6,0.6,0.6}\newcommand{\mydarkgray}{\color{mydarkgray}}
\definecolor{mydarkgrayA}{rgb}{0.3,0.3,0.3}\newcommand{\mydarkgrayA}{\color{mydarkgrayA}}
\definecolor{mywhite}{rgb}{1.0,1.0,1.0}\newcommand{\mywhite}{\color{mywhite}}

% Federico's gray box
\newcommand{\graybox}[1]{\vspace{0.3cm}\noindent
  \fcolorbox{black}{mygray}{\parbox{0.985\textwidth}{#1}}
\vspace{0.3cm}}

% Federico's gray box w/ title
\newcommand{\grayboxt}[2]{\vspace{0.3cm}\noindent
%  \fcolorbox{black}{mygray}{\parbox{0.985\textwidth}{{\bf #1} #2}}
  \fcolorbox{black}{mygray}{\begin{minipage}{0.985\textwidth}{\bf #1} #2\end{minipage}}
\vspace{0.3cm}}

% Mitko's gray box
\newcommand{\gbox}[1]{
  \begin{center}
    \fcolorbox{black}{gray}{
      \begin{minipage}[b]{0.98\textwidth}
        \begin{center}
          %\vspace{2mm}
          \begin{minipage}{0.97\textwidth}
            #1 
          \end{minipage}
          \vspace{2mm}
        \end{center}
      \end{minipage}
    }
  \end{center}
}

% Mitko's white box
\newcommand{\wbox}[1]{
  \begin{center}
    \fcolorbox{black}{white}{
      \begin{minipage}[b]{0.98\textwidth}
        \begin{center}
          %\vspace{2mm}
          \begin{minipage}{0.97\textwidth}
            #1 
          \end{minipage}
          \vspace{2mm}
        \end{center}
      \end{minipage}
    }
  \end{center}
}


\newtheorem{theo}{Theorem}
\newtheorem{defin}{Definition}
\newtheorem{reduction}{Reduction}
\newtheorem{prop}{Property}
\newtheorem{remark}{Remark}
\newtheorem{lemma}{Lemma}
\newtheorem{coro}{Corollary}
\newtheorem{scen}{Scenario}
\newtheorem{ex}{Exercise}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\title{Advanced Artificial Intelligence (DT4048)\\{\em Lab 2: Temporal Reasoning}}

\author{Masoumeh Mansouri, Federico Pecora\\Center for Applied Autonomous Sensor Systems\\\"Orebro University, SE-70182 Sweden\\\url{{masoumeh.mansouri, federico.pecora}@oru.se}}

\date{Fall term 2014 (HT2014)}

\begin{document}

\maketitle

\section{Setup}

Change directory to {\tt advanced-ai-lab-dt4048}, update the codebase, and compile (see lab 1);

\begin{lstlisting}
$ cd advanced-ai-lab-dt4048
$ svn update
$ gradle install
$ gradle eclipse
\end{lstlisting}

Open Eclipse and you are ready to start!

\section{Qualitative Temporal Reasoning}

Bla bla

\section{TCSP}
Open class {\tt lab2.EasyTestTCSP}, which shows how to instantiate a TCSP in the given framework.  Disjunctive constraints are instances of {\tt DistanceConstraints}. A {\tt MultiTimepoint} is a time point whose domain is a multitude of pairs of bounds, depending on the disjunctions in the constraints.  In the main method, two {\tt MultiTimepoint}s are created.  A disjunctive constraint added between one and the origin of time, while the other one is constrained (again with the origin of time) through a non-disjunctive constraint.  Observe the three printouts of the domains of these two variables: once before adding the constraints, once after adding the constraints, and once after solving.  This illustrates the difference between propagation and search in TCSPs: propagation cannot refine the domain of a variable bound by disjunctive constraints, whereas it can for a variable bound by non-disjunctive constraints.

Consider the following scenario:

\gbox{In a restaurant, we have both a human barman and a robot waiter. Both can prepare coffees, but only the robot waiter can deliver items to guests. A guest enters the restaurant and orders a coffee at time 3. The human waiter takes between 5 and 7 minutes to make a coffee, while the robot waiter takes 8 to 10 minutes to prepare a coffee. The trip form the counter where the prepared coffee is placed when ready to any guest table is either 4 to 10 minutes long if the robot navigates through the tables and guests, or 6 to 8 minutes long if it chooses a fixed predefined path. The serving coffee task is fully accomplished when the robot brings a sugar pot to the guest's table, which is instantaneous and occurs after serving the coffee. In order to avoid the coffee getting cold, the sugar pot should be served at most 12 minutes after the is coffee prepared. The whole serving time (i.e., waiting time for both coffee and sugar) should not exceed 15 minutes.}

The scenario above is the result of an autonomous decision process determining what to do for serving a coffee. We are interested in verifying whether the sequence of actions mentioned above is feasible with respect to all the temporal constraints.

{\ex{}\label{ex:ex1}  
Model the scenario above as a TCSP. Verify that the TCSP solver can find a solution.
\vspace{0.1cm}}

The {\tt SearchTreeFrame} window displays the portion of the search tree explored while solving the meta-CSP.

{\ex{}\label{ex:ex2}
Since the robot becomes slower over time, the restaurant eventually increases the maximum waiting time to be most 20 min. Model this fact as a constraint, solve the TCSP again, and observe the bounds of the time points.
\vspace{0.1cm}}

{\ex{}\label{ex:ex3}
Let the choice of bounds on each disjunctive constraint made by the TCSP solver be a ``realization'' of the scenario.  Implement code to extract the earliest time and latest time solutions for the particular realization found by the TCSP solver.
\vspace{0.1cm}}

{\ex{}\label{ex:ex4}
Note that there are solutions other than earliest and latest time solution. Implement code to extract a solution that is different form the solutions extracted in the previous exercise.
\vspace{0.1cm}}

{\ex{}\label{ex:ex5}
Let the choice of bounds on each disjunctive constraint made by the TCSP solver be a ``realization'' of the scenario.  Use the TCSP solver to find another realization.
\vspace{0.1cm}}


\section{STP}

Assume you are given a metric temporal constraint network $S$, and that the timepoints and constraints in this network represent readings coming from sensors in the environment.  Verifying if given temporal relations $H$ among sensor readings hold can be achieved by modeling the relations in $H$ as temporal constraints and verifying if the STP $S \cup H$ is consistent.  As we know from the lectures, verifying the consistency of a STP can be achieved in $\Theta(n^3)$.  Hence, the STP is thus an appropriate model for verifying the consistency of temporal hypotheses.

%\bibliographystyle{apalike}
%\bibliography{metaCSP}

\end{document}

